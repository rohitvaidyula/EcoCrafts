{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n/** Convenient class for storing tensor-related data. */\nexport class DataStorage {\n  constructor(backend, dataMover) {\n    this.backend = backend;\n    this.dataMover = dataMover;\n    this.data = new WeakMap();\n    this.dataIdsCount = 0;\n  }\n  get(dataId) {\n    if (!this.data.has(dataId)) {\n      this.dataMover.moveData(this.backend, dataId);\n    }\n    return this.data.get(dataId);\n  }\n  set(dataId, value) {\n    this.dataIdsCount++;\n    this.data.set(dataId, value);\n  }\n  has(dataId) {\n    return this.data.has(dataId);\n  }\n  delete(dataId) {\n    this.dataIdsCount--;\n    return this.data.delete(dataId);\n  }\n  numDataIds() {\n    return this.dataIdsCount;\n  }\n}\n/**\n * The interface that defines the kernels that should be implemented when\n * adding a new backend. New backends don't need to implement every one of the\n * methods, this can be done gradually (throw an error for unimplemented\n * methods).\n */\nexport class KernelBackend {\n  /**\n   * Decrease the complex ref count for the dataId, this is useful for WebGL\n   * backend to keep the real and imag components of the complex tensor in sync\n   * with the engine. WASM and node do not have internal ref count, they will\n   * use on the default implementation.\n   * @param dataId\n   */\n  decComplexRef(dataId) {\n    return;\n  }\n  time(f) {\n    return notYetImplemented('time');\n  }\n  read(dataId) {\n    return notYetImplemented('read');\n  }\n  readSync(dataId) {\n    return notYetImplemented('readSync');\n  }\n  numDataIds() {\n    return notYetImplemented('numDataIds');\n  }\n  disposeData(dataId) {\n    return notYetImplemented('disposeData');\n  }\n  write(values, shape, dtype) {\n    return notYetImplemented('write');\n  }\n  move(dataId, values, shape, dtype) {\n    return notYetImplemented('move');\n  }\n  memory() {\n    return notYetImplemented('memory');\n  }\n  /** Returns the highest precision for floats in bits (e.g. 16 or 32) */\n  floatPrecision() {\n    return notYetImplemented('floatPrecision');\n  }\n  /** Returns the smallest representable number.  */\n  epsilon() {\n    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n  }\n  batchMatMul(a, b, transposeA, transposeB) {\n    return notYetImplemented('batchMatMul');\n  }\n  fusedBatchMatMul({\n    a,\n    b,\n    transposeA,\n    transposeB,\n    bias,\n    activation,\n    preluActivationWeights\n  }) {\n    return notYetImplemented('fusedBatchMatMul');\n  }\n  slice(x, begin, size) {\n    return notYetImplemented('slice');\n  }\n  stridedSlice(x, begin, end, strides) {\n    return notYetImplemented('stridedSlice');\n  }\n  unstack(x, axis) {\n    return notYetImplemented('unstack');\n  }\n  reverse(a, axis) {\n    return notYetImplemented('reverse');\n  }\n  concat(tensors, axis) {\n    return notYetImplemented('concat');\n  }\n  neg(a) {\n    return notYetImplemented('neg');\n  }\n  add(a, b) {\n    return notYetImplemented('add');\n  }\n  addN(tensors) {\n    return notYetImplemented('addN');\n  }\n  subtract(a, b) {\n    return notYetImplemented('subtract');\n  }\n  multiply(a, b) {\n    return notYetImplemented('multiply');\n  }\n  realDivide(a, b) {\n    return notYetImplemented('realDivide');\n  }\n  floorDiv(a, b) {\n    return notYetImplemented('floorDiv');\n  }\n  sum(x, axes) {\n    return notYetImplemented('sum');\n  }\n  prod(x, axes) {\n    return notYetImplemented('prod');\n  }\n  unsortedSegmentSum(x, segmentIds, numSegments) {\n    return notYetImplemented('unsortedSegmentSum');\n  }\n  argMin(x, axis) {\n    return notYetImplemented('argMin');\n  }\n  argMax(x, axis) {\n    return notYetImplemented('argMax');\n  }\n  equal(a, b) {\n    return notYetImplemented('equal');\n  }\n  notEqual(a, b) {\n    return notYetImplemented('notEqual');\n  }\n  less(a, b) {\n    return notYetImplemented('less');\n  }\n  lessEqual(a, b) {\n    return notYetImplemented('lessEqual');\n  }\n  greater(a, b) {\n    return notYetImplemented('greater');\n  }\n  greaterEqual(a, b) {\n    return notYetImplemented('greaterEqual');\n  }\n  logicalNot(a) {\n    return notYetImplemented('logicalNot');\n  }\n  logicalAnd(a, b) {\n    return notYetImplemented('logicalAnd');\n  }\n  logicalOr(a, b) {\n    return notYetImplemented('logicalOr');\n  }\n  where(condition) {\n    return notYetImplemented('where');\n  }\n  select(condition, a, b) {\n    return notYetImplemented('select');\n  }\n  topk(x, k, sorted) {\n    return notYetImplemented('topk');\n  }\n  min(x, axes) {\n    return notYetImplemented('min');\n  }\n  minimum(a, b) {\n    return notYetImplemented('minimum');\n  }\n  mod(a, b) {\n    return notYetImplemented('mod');\n  }\n  max(x, axes) {\n    return notYetImplemented('max');\n  }\n  maximum(a, b) {\n    return notYetImplemented('maximum');\n  }\n  all(x, axes) {\n    return notYetImplemented('all');\n  }\n  any(x, axes) {\n    return notYetImplemented('any');\n  }\n  squaredDifference(a, b) {\n    return notYetImplemented('squaredDifference');\n  }\n  ceil(x) {\n    return notYetImplemented('ceil');\n  }\n  floor(x) {\n    return notYetImplemented('floor');\n  }\n  round(x) {\n    return notYetImplemented('round');\n  }\n  sign(x) {\n    return notYetImplemented('sign');\n  }\n  isNaN(x) {\n    return notYetImplemented('isNaN');\n  }\n  isInf(x) {\n    return notYetImplemented('isInf');\n  }\n  isFinite(x) {\n    return notYetImplemented('isFinite');\n  }\n  pow(a, b) {\n    return notYetImplemented('pow');\n  }\n  exp(x) {\n    return notYetImplemented('exp');\n  }\n  expm1(x) {\n    return notYetImplemented('expm1');\n  }\n  softmax(x, dim) {\n    return notYetImplemented('softmax');\n  }\n  log(x) {\n    return notYetImplemented('log');\n  }\n  log1p(x) {\n    return notYetImplemented('log1p');\n  }\n  sqrt(x) {\n    return notYetImplemented('sqrt');\n  }\n  rsqrt(x) {\n    return notYetImplemented('rsqrt');\n  }\n  square(x) {\n    return notYetImplemented('square');\n  }\n  reciprocal(x) {\n    return notYetImplemented('reciprocal');\n  }\n  relu(x) {\n    return notYetImplemented('relu');\n  }\n  relu6(x) {\n    return notYetImplemented('relu6');\n  }\n  prelu(x, a) {\n    return notYetImplemented('prelu');\n  }\n  elu(x) {\n    return notYetImplemented('elu');\n  }\n  eluDer(dy, y) {\n    return notYetImplemented('eluDer');\n  }\n  selu(x) {\n    return notYetImplemented('selu');\n  }\n  int(x) {\n    return notYetImplemented('int');\n  }\n  clip(x, min, max) {\n    return notYetImplemented('clip');\n  }\n  abs(x) {\n    return notYetImplemented('abs');\n  }\n  complexAbs(x) {\n    return notYetImplemented('complexAbs');\n  }\n  sigmoid(x) {\n    return notYetImplemented('sigmoid');\n  }\n  softplus(x) {\n    return notYetImplemented('softplus');\n  }\n  sin(x) {\n    return notYetImplemented('sin');\n  }\n  cos(x) {\n    return notYetImplemented('cos');\n  }\n  tan(x) {\n    return notYetImplemented('tan');\n  }\n  asin(x) {\n    return notYetImplemented('asin');\n  }\n  acos(x) {\n    return notYetImplemented('acos');\n  }\n  atan(x) {\n    return notYetImplemented('atan');\n  }\n  atan2(a, b) {\n    return notYetImplemented('atan2');\n  }\n  sinh(x) {\n    return notYetImplemented('sinh');\n  }\n  cosh(x) {\n    return notYetImplemented('cosh');\n  }\n  tanh(x) {\n    return notYetImplemented('tanh');\n  }\n  asinh(x) {\n    return notYetImplemented('asinh');\n  }\n  acosh(x) {\n    return notYetImplemented('acosh');\n  }\n  atanh(x) {\n    return notYetImplemented('atanh');\n  }\n  erf(x) {\n    return notYetImplemented('erf');\n  }\n  step(x, alpha) {\n    return notYetImplemented('step');\n  }\n  fusedConv2d({\n    input,\n    filter,\n    convInfo,\n    bias,\n    activation,\n    preluActivationWeights\n  }) {\n    return notYetImplemented('fusedConv2d');\n  }\n  conv2d(x, filter, convInfo) {\n    return notYetImplemented('conv2d');\n  }\n  conv2dDerInput(dy, filter, convInfo) {\n    return notYetImplemented('conv2dDerInput');\n  }\n  conv2dDerFilter(x, dY, convInfo) {\n    return notYetImplemented('conv2dDerFilter');\n  }\n  fusedDepthwiseConv2D({\n    input,\n    filter,\n    convInfo,\n    bias,\n    activation,\n    preluActivationWeights\n  }) {\n    return notYetImplemented('fusedDepthwiseConv2D');\n  }\n  depthwiseConv2D(input, filter, convInfo) {\n    return notYetImplemented('depthwiseConv2D');\n  }\n  depthwiseConv2DDerInput(dy, filter, convInfo) {\n    return notYetImplemented('depthwiseConv2DDerInput');\n  }\n  depthwiseConv2DDerFilter(x, dY, convInfo) {\n    return notYetImplemented('depthwiseConv2DDerFilter');\n  }\n  conv3d(x, filter, convInfo) {\n    return notYetImplemented('conv3d');\n  }\n  conv3dDerInput(dy, filter, convInfo) {\n    return notYetImplemented('conv3dDerInput');\n  }\n  conv3dDerFilter(x, dY, convInfo) {\n    return notYetImplemented('conv3dDerFilter');\n  }\n  maxPool(x, convInfo) {\n    return notYetImplemented('maxPool');\n  }\n  maxPoolBackprop(dy, x, y, convInfo) {\n    return notYetImplemented('maxPoolBackprop');\n  }\n  avgPool(x, convInfo) {\n    return notYetImplemented('avgPool');\n  }\n  avgPoolBackprop(dy, x, convInfo) {\n    return notYetImplemented('avgPoolBackprop');\n  }\n  avgPool3d(x, convInfo) {\n    return notYetImplemented('avgPool3d');\n  }\n  avgPool3dBackprop(dy, x, convInfo) {\n    return notYetImplemented('avgPool3dBackprop');\n  }\n  maxPool3d(x, convInfo) {\n    return notYetImplemented('maxPool3d');\n  }\n  maxPool3dBackprop(dy, x, y, convInfo) {\n    return notYetImplemented('maxPool3dBackprop');\n  }\n  reshape(x, shape) {\n    return notYetImplemented('reshape');\n  }\n  cast(x, dtype) {\n    return notYetImplemented('cast');\n  }\n  tile(x, reps) {\n    return notYetImplemented('tile');\n  }\n  pad(x, paddings, constantValue) {\n    return notYetImplemented('pad');\n  }\n  transpose(x, perm) {\n    return notYetImplemented('transpose');\n  }\n  gather(x, indices, axis, batchDims = 0) {\n    return notYetImplemented('gather');\n  }\n  gatherND(x, indices) {\n    return notYetImplemented('gatherND');\n  }\n  scatterND(indices, updates, shape) {\n    return notYetImplemented('scatterND');\n  }\n  batchToSpaceND(x, blockShape, crops) {\n    return notYetImplemented('batchToSpaceND');\n  }\n  spaceToBatchND(x, blockShape, paddings) {\n    return notYetImplemented('spaceToBatchND');\n  }\n  resizeBilinear(x, newHeight, newWidth, alignCorners, halfPixelCenters) {\n    return notYetImplemented('resizeBilinear');\n  }\n  resizeBilinearBackprop(dy, x, alignCorners) {\n    return notYetImplemented('resizeBilinearBackprop');\n  }\n  resizeNearestNeighbor(x, newHEight, newWidth, alignCorners, halfPixelCenters) {\n    return notYetImplemented('resizeNearestNeighbor');\n  }\n  resizeNearestNeighborBackprop(dy, x, alignCorners) {\n    return notYetImplemented('resizeNearestNeighborBackprop');\n  }\n  batchNorm(x, mean, variance, offset, scale, varianceEpsilon) {\n    return notYetImplemented('batchNorm');\n  }\n  localResponseNormalization4D(x, radius, bias, alpha, beta) {\n    return notYetImplemented('localResponseNormalization4D');\n  }\n  LRNGrad(dy, inputImage, outputImage, radius, bias, alpha, beta) {\n    return notYetImplemented('LRNGrad');\n  }\n  multinomial(logits, normalized, numSamples, seed) {\n    return notYetImplemented('multinomial');\n  }\n  oneHot(indices, depth, onValue, offValue) {\n    return notYetImplemented('oneHot');\n  }\n  cumsum(x, axis, exclusive, reverse) {\n    return notYetImplemented('cumsum');\n  }\n  nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n    return notYetImplemented('nonMaxSuppression');\n  }\n  fft(x) {\n    return notYetImplemented('fft');\n  }\n  ifft(x) {\n    return notYetImplemented('ifft');\n  }\n  complex(real, imag) {\n    return notYetImplemented('complex');\n  }\n  real(input) {\n    return notYetImplemented('real');\n  }\n  imag(input) {\n    return notYetImplemented('imag');\n  }\n  cropAndResize(image, boxes, boxIndex, cropSize, method, extrapolationValue) {\n    return notYetImplemented('cropAndResize');\n  }\n  depthToSpace(x, blockSize, dataFormat) {\n    return notYetImplemented('depthToSpace');\n  }\n  // Aligns with the \"SplitV\" kernel in TensorFlow.\n  split(value, sizeSplits, axis) {\n    return notYetImplemented('split');\n  }\n  sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {\n    return notYetImplemented('sparseToDense');\n  }\n  diag(x) {\n    return notYetImplemented('diag');\n  }\n  fill(shape, value, dtype) {\n    return notYetImplemented('fill');\n  }\n  onesLike(x) {\n    return notYetImplemented('onesLike');\n  }\n  zerosLike(x) {\n    return notYetImplemented('zerosLike');\n  }\n  linspace(start, stop, num) {\n    return notYetImplemented('linspace');\n  }\n  dispose() {\n    return notYetImplemented('dispose');\n  }\n}\nfunction notYetImplemented(kernelName) {\n  throw new Error(`'${kernelName}' not yet implemented or not found in the registry. ` + `This kernel may not be supported by the tfjs backend you have chosen`);\n}","map":null,"metadata":{},"sourceType":"module"}