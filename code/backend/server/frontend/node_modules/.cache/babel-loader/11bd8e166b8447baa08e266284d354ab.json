{"ast":null,"code":"/**\r\n * ExecutionContext captures the runtime environment of the node. It keeps\r\n * track of the current frame and iteration for the control flow ops.\r\n *\r\n * For example, typical Dynamic RNN model may contain loops, for which\r\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\r\n * current execution frame, and NextIteration Nodes for iteration id increment.\r\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\r\n */\nexport class ExecutionContext {\n  constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n  newFrame(id, frameName) {\n    return {\n      id,\n      frameName,\n      iterationId: 0\n    };\n  }\n  /**\r\n   * Set the current context\r\n   * @param contexts: ExecutionContextInfo[] the current path of execution\r\n   * frames\r\n   */\n  set currentContext(contexts) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n  get currentContext() {\n    return this.contexts;\n  }\n  /**\r\n   * Returns the current context in string format.\r\n   */\n  get currentContextId() {\n    return this._currentContextIds[0];\n  }\n  /**\r\n   * Returns the current context and all parent contexts in string format.\r\n   * This allow access to the nodes in the current and parent frames.\r\n   */\n  get currentContextIds() {\n    return this._currentContextIds;\n  }\n  generateCurrentContextIds() {\n    const names = [];\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n    names.push('');\n    this._currentContextIds = names;\n  }\n  contextIdforContexts(contexts) {\n    return contexts ? contexts.map(context => context.id === 0 && context.iterationId === 0 ? '' : `${context.frameName}-${context.iterationId}`).join('/') : '';\n  }\n  /**\r\n   * Enter a new frame, a new context is pushed on the current context list.\r\n   * @param frameId new frame id\r\n   */\n  enterFrame(frameId) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n  /**\r\n   * Exit the current frame, the last context is removed from the current\r\n   * context list.\r\n   */\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n  /**\r\n   * Enter the next iteration of a loop, the iteration id of last context is\r\n   * increased.\r\n   */\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n  getWeight(name) {\n    return this.weightMap[name];\n  }\n  addTensorArray(tensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n  getTensorArray(id) {\n    return this.tensorArrayMap[id];\n  }\n  addTensorList(tensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n  getTensorList(id) {\n    return this.tensorListMap[id];\n  }\n  dispose(keepIds) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}