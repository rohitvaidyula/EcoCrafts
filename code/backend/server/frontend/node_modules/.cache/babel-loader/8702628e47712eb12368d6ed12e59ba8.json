{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { assertTypesMatch } from '../tensor_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { add } from './add';\nimport { div } from './div';\nimport { mul } from './mul';\nimport { op } from './operation';\nimport { pow } from './pow';\nimport { scalar } from './scalar';\nimport { sub } from './sub';\n/**\r\n * Compute the moving average of a variable.\r\n *\r\n * Without zeroDebias, the moving average operation is defined by:\r\n *   `v += delta`\r\n * where\r\n *   `delta = (1 - decay) * (x - v)`\r\n *\r\n * With zeroDebias (default), the `delta` term is scaled to debias the\r\n * effect of the (assumed) zero-initialization of `v`.\r\n *   `delta /= (1 - decay ^ step)`\r\n *\r\n * For more details on the zero-debiasing algorithm, see:\r\n *   https://arxiv.org/abs/1412.6980\r\n *\r\n * Note that this function is completely stateless and does not keep track of\r\n * step count. The step count needs to be maintained by the caller and passed\r\n * in as `step`.\r\n *\r\n * @param v The current moving average value.\r\n * @param x New input value, must have the same shape and dtype as `v`.\r\n * @param decay The decay factor. Typical values are 0.95 and 0.99.\r\n * @param step Step count.\r\n * @param zeroDebias: Whether zeroDebias is to be performed (default: `true`).\r\n * @returns The new moving average value.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Moving Average'}\r\n */\nfunction movingAverage_(v, x, decay, step, zeroDebias = true) {\n  const $v = convertToTensor(v, 'v', 'movingAverage');\n  const $x = convertToTensor(x, 'x', 'movingAverage');\n  const $decay = convertToTensor(decay, 'decay', 'movingAverage');\n  assertTypesMatch($v, $x);\n  util.assert(util.arraysEqual($v.shape, $x.shape), () => 'Shape mismatch in v and x');\n  const one = scalar(1);\n  const oneMinusDecay = sub(one, $decay);\n  let update = mul(sub($x, $v), oneMinusDecay);\n  if (zeroDebias) {\n    util.assert(step != null, () => 'When using zeroDebias: true, step is required.');\n    const $step = convertToTensor(step, 'step', 'movingAverage');\n    update = div(update, sub(one, pow($decay, $step)));\n  }\n  return add($v, update);\n}\nexport const movingAverage = op({\n  movingAverage_\n});","map":null,"metadata":{},"sourceType":"module"}