{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../../engine';\nimport { CropAndResize } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { op } from '../operation';\n/**\r\n * Extracts crops from the input image tensor and resizes them using bilinear\r\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\r\n * to a common output size specified by cropSize.\r\n *\r\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\r\n *     where imageHeight and imageWidth must be positive, specifying the\r\n *     batch of images from which to take crops\r\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\r\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\r\n *     coordinates of the box in the boxInd[i]'th image in the batch\r\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\r\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\r\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\r\n *     specifying the size to which all crops are resized to.\r\n * @param method Optional string from `'bilinear' | 'nearest'`,\r\n *     defaults to bilinear, which specifies the sampling method for resizing\r\n * @param extrapolationValue A threshold for deciding when to remove boxes based\r\n *     on score. Defaults to 0.\r\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\r\n */\nfunction cropAndResize_(image, boxes, boxInd, cropSize, method = 'bilinear', extrapolationValue = 0) {\n  const $image = convertToTensor(image, 'image', 'cropAndResize');\n  const $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n  const $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n  const numBoxes = $boxes.shape[0];\n  util.assert($image.rank === 4, () => 'Error in cropAndResize: image must be rank 4,' + `but got rank ${$image.rank}.`);\n  util.assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` + `but had shape ${$boxes.shape}.`);\n  util.assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` + `but had shape ${$boxes.shape}.`);\n  util.assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got ` + `length ${cropSize.length}.`);\n  util.assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);\n  util.assert(method === 'bilinear' || method === 'nearest', () => `method must be bilinear or nearest, but was ${method}`);\n  const inputs = {\n    image: $image,\n    boxes: $boxes,\n    boxInd: $boxInd\n  };\n  const attrs = {\n    method,\n    extrapolationValue,\n    cropSize\n  };\n  const res = ENGINE.runKernel(CropAndResize, inputs, attrs);\n  return res;\n}\nexport const cropAndResize = op({\n  cropAndResize_\n});","map":null,"metadata":{},"sourceType":"module"}