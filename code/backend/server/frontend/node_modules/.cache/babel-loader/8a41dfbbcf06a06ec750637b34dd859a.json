{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Use of this source code is governed by an MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n * =============================================================================\r\n */\n/**\r\n * Math utility functions.\r\n *\r\n * This file contains some frequently used math function that operates on\r\n * number[] or Float32Array and return a number. Many of these functions are\r\n * not-so-thick wrappers around TF.js Core functions. But they offer the\r\n * convenience of\r\n * 1) not having to convert the inputs into Tensors,\r\n * 2) not having to convert the returned Tensors to numbers.\r\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { scalar, tensor1d } from '@tensorflow/tfjs-core';\nimport { ValueError } from '../errors';\n/**\r\n * Determine if a number is an integer.\r\n */\nexport function isInteger(x) {\n  return x === parseInt(x.toString(), 10);\n}\n/**\r\n * Calculate the product of an array of numbers.\r\n * @param array The array to calculate the product over.\r\n * @param begin Beginning index, inclusive.\r\n * @param end Ending index, exclusive.\r\n * @return The product.\r\n */\nexport function arrayProd(array, begin, end) {\n  if (begin == null) {\n    begin = 0;\n  }\n  if (end == null) {\n    end = array.length;\n  }\n  let prod = 1;\n  for (let i = begin; i < end; ++i) {\n    prod *= array[i];\n  }\n  return prod;\n}\n/**\r\n * A helper function transforms the two input types to an instance of Tensor1D,\r\n * so the return value can be fed directly into various TF.js Core functions.\r\n * @param array\r\n */\nfunction toArray1D(array) {\n  array = Array.isArray(array) ? new Float32Array(array) : array;\n  return tensor1d(array);\n}\n/**\r\n * Compute minimum value.\r\n * @param array\r\n * @return minimum value.\r\n */\nexport function min(array) {\n  return tfc.min(toArray1D(array)).dataSync()[0];\n}\n/**\r\n * Compute maximum value.\r\n * @param array\r\n * @return maximum value\r\n */\nexport function max(array) {\n  return tfc.max(toArray1D(array)).dataSync()[0];\n}\n/**\r\n * Compute sum of array.\r\n * @param array\r\n * @return The sum.\r\n */\nexport function sum(array) {\n  return tfc.sum(toArray1D(array)).dataSync()[0];\n}\n/**\r\n * Compute mean of array.\r\n * @param array\r\n * @return The mean.\r\n */\nexport function mean(array) {\n  return sum(array) / array.length;\n}\n/**\r\n * Compute variance of array.\r\n * @param array\r\n * @return The variance.\r\n */\nexport function variance(array) {\n  const demeaned = tfc.sub(toArray1D(array), scalar(mean(array)));\n  const sumSquare = tfc.sum(tfc.mul(demeaned, demeaned)).dataSync()[0];\n  return sumSquare / array.length;\n}\n/**\r\n * Compute median of array.\r\n * @param array\r\n * @return The median value.\r\n */\nexport function median(array) {\n  const arraySorted = array.slice().sort((a, b) => a - b);\n  const lowIdx = Math.floor((arraySorted.length - 1) / 2);\n  const highIdx = Math.ceil((arraySorted.length - 1) / 2);\n  if (lowIdx === highIdx) {\n    return arraySorted[lowIdx];\n  }\n  return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;\n}\n/**\r\n * Generate an array of integers in [begin, end).\r\n * @param begin Beginning integer, inclusive.\r\n * @param end Ending integer, exclusive.\r\n * @returns Range array.\r\n * @throws ValueError, iff `end` < `begin`.\r\n */\nexport function range(begin, end) {\n  if (end < begin) {\n    throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);\n  }\n  const out = [];\n  for (let i = begin; i < end; ++i) {\n    out.push(i);\n  }\n  return out;\n}","map":null,"metadata":{},"sourceType":"module"}