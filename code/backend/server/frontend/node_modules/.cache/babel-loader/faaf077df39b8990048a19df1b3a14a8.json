{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Prod, upcastType, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { transpose } from './Transpose';\nexport function prodImpl(xShape, xDtype, xVals, reductionAxes) {\n  const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n  const outDtype = upcastType(xDtype, 'int32');\n  const outVals = util.makeZerosTypedArray(util.sizeFromShape(outShape), outDtype);\n  const reduceSize = util.sizeFromShape(reduceShape);\n  for (let i = 0; i < outVals.length; ++i) {\n    const offset = i * reduceSize;\n    let prod = 1;\n    for (let j = 0; j < reduceSize; ++j) {\n      prod *= xVals[offset + j];\n    }\n    outVals[i] = prod;\n  }\n  return {\n    outVals,\n    outShape,\n    outDtype\n  };\n}\nexport function prod(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    axis,\n    keepDims\n  } = attrs;\n  assertNotComplex(x, 'prod');\n  const xRank = x.shape.length;\n  const axes = util.parseAxisParam(axis, x.shape);\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n  let reductionAxes = axes;\n  let permutedX = x;\n  const intermediateTensorInfos = [];\n  if (permutation != null) {\n    permutedX = transpose({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n  const xVals = backend.data.get(permutedX.dataId).values;\n  const {\n    outVals,\n    outShape,\n    outDtype\n  } = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n  let resultShape = outShape;\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n  intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\nexport const prodConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod\n};","map":null,"metadata":{},"sourceType":"module"}