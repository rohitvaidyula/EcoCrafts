{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { deprecationWarn } from '../globals';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { add } from './add';\nimport { div } from './div';\nimport { maximum } from './maximum';\nimport { minimum } from './minimum';\nimport { mod } from './mod';\nimport { mul } from './mul';\nimport { op } from './operation';\nimport { pow } from './pow';\nimport { squaredDifference } from './squared_difference';\nimport { sub } from './sub';\n/**\r\n * @deprecated\r\n * Adds two `tf.Tensor`s element-wise, A + B.\r\n *\r\n * Inputs must be the same shape. For broadcasting support, use add() instead.\r\n *\r\n * @param a The first Tensor to add element-wise.\r\n * @param b The second Tensor to add element-wise.\r\n */\nfunction addStrict_(a, b) {\n  deprecationWarn('strict variants of ops have been deprecated ' + 'and will be removed in future');\n  const $a = convertToTensor(a, 'a', 'addStrict');\n  const $b = convertToTensor(b, 'b', 'addStrict');\n  util.assertShapesMatch($a.shape, $b.shape, 'Error in addStrict: ');\n  return add($a, $b);\n}\n/**\r\n * @deprecated\r\n * Subtracts two `tf.Tensor`s element-wise, A - B. Inputs must\r\n * be the same shape.\r\n *\r\n * For broadcasting support, use `tf.sub` instead.\r\n *\r\n * @param a The first Tensor to subtract element-wise.\r\n * @param b The second Tensor to subtract element-wise.\r\n */\nfunction subStrict_(a, b) {\n  deprecationWarn('strict variants of ops have been deprecated ' + 'and will be removed in future');\n  const $a = convertToTensor(a, 'a', 'subStrict');\n  const $b = convertToTensor(b, 'b', 'subStrict');\n  util.assertShapesMatch($a.shape, $b.shape, 'Error in subStrict: ');\n  return sub($a, $b);\n}\n/**\r\n * @deprecated\r\n * Computes the power of one `tf.Tensor` to another. Inputs must\r\n * be the same shape.\r\n *\r\n * For broadcasting support, use `tf.pow` instead.\r\n *\r\n * @param base The base tensor to pow element-wise.\r\n * @param exp The exponent tensor to pow element-wise.\r\n */\nfunction powStrict_(base, exp) {\n  deprecationWarn('strict variants of ops have been deprecated ' + 'and will be removed in future');\n  util.assertShapesMatch(base.shape, exp.shape, 'Error in powStrict: ');\n  return pow(base, exp);\n}\n/**\r\n * @deprecated\r\n * Multiplies two `tf.Tensor`s element-wise, A * B.\r\n *\r\n * Inputs must be the same shape. For broadcasting support, use `tf.mul`.\r\n *\r\n * @param a The first tensor to multiply.\r\n * @param b The first tensor to multiply. Must have the same\r\n *    dtype as `a`.\r\n */\nfunction mulStrict_(a, b) {\n  deprecationWarn('strict variants of ops have been deprecated ' + 'and will be removed in future');\n  const $a = convertToTensor(a, 'a', 'mul');\n  const $b = convertToTensor(b, 'b', 'mul');\n  util.assertShapesMatch($a.shape, $b.shape, 'Error in multiplyStrict: ');\n  return mul($a, $b);\n}\n/**\r\n * @deprecated\r\n * Divides two `tf.Tensor`s element-wise, A / B. Inputs must\r\n * be the same shape.\r\n *\r\n * @param a The first tensor as the numerator for element-wise division.\r\n * @param b The second tensor as the denominator for element-wise division.\r\n */\nfunction divStrict_(a, b) {\n  deprecationWarn('strict variants of ops have been deprecated ' + 'and will be removed in future');\n  const $a = convertToTensor(a, 'a', 'div');\n  const $b = convertToTensor(b, 'b', 'div');\n  util.assertShapesMatch($a.shape, $b.shape, 'Error in divideStrict: ');\n  return div($a, $b);\n}\n/**\r\n * @deprecated\r\n * Returns the mod of a and b (`a < b ? a : b`) element-wise. Inputs must\r\n * be the same shape. For broadcasting support, use mod().\r\n *\r\n * @param a The first tensor.\r\n * @param b The second tensor. Must have the same dtype as `a`.\r\n */\nfunction modStrict_(a, b) {\n  deprecationWarn('strict variants of ops have been deprecated ' + 'and will be removed in future');\n  const $a = convertToTensor(a, 'a', 'modStrict');\n  const $b = convertToTensor(b, 'b', 'modStrict');\n  util.assertShapesMatch($a.shape, $b.shape, 'Error in modStrict: ');\n  return mod($a, $b);\n}\n/**\r\n * @deprecated\r\n * Returns the min of a and b (`a < b ? a : b`) element-wise. Inputs must\r\n * be the same shape. For broadcasting support, use minimum().\r\n *\r\n * @param a The first tensor.\r\n * @param b The second tensor. Must have the same dtype as `a`.\r\n */\nfunction minimumStrict_(a, b) {\n  deprecationWarn('strict variants of ops have been deprecated ' + 'and will be removed in future');\n  const $a = convertToTensor(a, 'a', 'minimumStrict');\n  const $b = convertToTensor(b, 'b', 'minimumStrict');\n  util.assertShapesMatch($a.shape, $b.shape, 'Error in minimumStrict: ');\n  return minimum($a, $b);\n}\n/**\r\n * @deprecated\r\n * Returns the max of a and b (`a > b ? a : b`) element-wise. Inputs must\r\n * be the same shape. For broadcasting support, use maximum().\r\n *\r\n * @param a The first tensor.\r\n * @param b The second tensor. Must have the same dtype as `a`.\r\n */\nfunction maximumStrict_(a, b) {\n  deprecationWarn('strict variants of ops have been deprecated ' + 'and will be removed in future');\n  const $a = convertToTensor(a, 'a', 'maximumStrict');\n  const $b = convertToTensor(b, 'b', 'maximumStrict');\n  util.assertShapesMatch($a.shape, $b.shape, 'Error in maximumStrict: ');\n  return maximum($a, $b);\n}\n/**\r\n * @deprecated\r\n * Returns (a - b) * (a - b) element-wise.\r\n *\r\n * Inputs must be the same shape. For broadcasting support, use\r\n * `tf.squaredDifference` instead.\r\n *\r\n * @param a The first tensor.\r\n * @param b The second tensor. Must have the same type as `a`.\r\n */\nfunction squaredDifferenceStrict_(a, b) {\n  deprecationWarn('strict variants of ops have been deprecated ' + 'and will be removed in future');\n  const $a = convertToTensor(a, 'a', 'squaredDifferenceStrict');\n  const $b = convertToTensor(b, 'b', 'squaredDifferenceStrict');\n  util.assertShapesMatch($a.shape, $b.shape, 'Error in squaredDifferenceStrict: ');\n  return squaredDifference($a, $b);\n}\nexport const addStrict = op({\n  addStrict_\n});\nexport const divStrict = op({\n  divStrict_\n});\nexport const maximumStrict = op({\n  maximumStrict_\n});\nexport const minimumStrict = op({\n  minimumStrict_\n});\nexport const modStrict = op({\n  modStrict_\n});\nexport const mulStrict = op({\n  mulStrict_\n});\nexport const powStrict = op({\n  powStrict_\n});\nexport const squaredDifferenceStrict = op({\n  squaredDifferenceStrict_\n});\nexport const subStrict = op({\n  subStrict_\n});","map":null,"metadata":{},"sourceType":"module"}