{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { assert } from './util';\n/**\r\n * Serializable defines the serialization contract.\r\n *\r\n * TFJS requires serializable classes to return their className when asked\r\n * to avoid issues with minification.\r\n */\nexport class Serializable {\n  /**\r\n   * Return the class name for this class to use in serialization contexts.\r\n   *\r\n   * Generally speaking this will be the same thing that constructor.name\r\n   * would have returned.  However, the class name needs to be robust\r\n   * against minification for serialization/deserialization to work properly.\r\n   *\r\n   * There's also places such as initializers.VarianceScaling, where\r\n   * implementation details between different languages led to different\r\n   * class hierarchies and a non-leaf node is used for serialization purposes.\r\n   */\n  getClassName() {\n    return this.constructor.className;\n  }\n  /**\r\n   * Creates an instance of T from a ConfigDict.\r\n   *\r\n   * This works for most descendants of serializable.  A few need to\r\n   * provide special handling.\r\n   * @param cls A Constructor for the class to instantiate.\r\n   * @param config The Configuration for the object.\r\n   */\n  /** @nocollapse */\n  static fromConfig(cls, config) {\n    return new cls(config);\n  }\n}\n/**\r\n * Maps string keys to class constructors.\r\n *\r\n * Used during (de)serialization from the cross-language JSON format, which\r\n * requires the class name in the serialization format matches the class\r\n * names as used in Python, should it exist.\r\n */\nexport class SerializationMap {\n  constructor() {\n    this.classNameMap = {};\n  }\n  /**\r\n   * Returns the singleton instance of the map.\r\n   */\n  static getMap() {\n    if (SerializationMap.instance == null) {\n      SerializationMap.instance = new SerializationMap();\n    }\n    return SerializationMap.instance;\n  }\n  /**\r\n   * Registers the class as serializable.\r\n   */\n  static register(cls) {\n    SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];\n  }\n}\n/**\r\n * Register a class with the serialization map of TensorFlow.js.\r\n *\r\n * This is often used for registering custom Layers, so they can be\r\n * serialized and deserialized.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * class MyCustomLayer extends tf.layers.Layer {\r\n *   static className = 'MyCustomLayer';\r\n *\r\n *   constructor(config) {\r\n *     super(config);\r\n *   }\r\n * }\r\n * tf.serialization.registerClass(MyCustomLayer);\r\n * ```\r\n *\r\n * @param cls The class to be registered. It must have a public static member\r\n *   called `className` defined and the value must be a non-empty string.\r\n *\r\n * @doc {heading: 'Models', subheading: 'Serialization', ignoreCI: true}\r\n */\nexport function registerClass(cls) {\n  assert(cls.className != null, () => `Class being registered does not have the static className ` + `property defined.`);\n  assert(typeof cls.className === 'string', () => `className is required to be a string, but got type ` + typeof cls.className);\n  assert(cls.className.length > 0, () => `Class being registered has an empty-string as its className, ` + `which is disallowed.`);\n  SerializationMap.register(cls);\n}","map":null,"metadata":{},"sourceType":"module"}