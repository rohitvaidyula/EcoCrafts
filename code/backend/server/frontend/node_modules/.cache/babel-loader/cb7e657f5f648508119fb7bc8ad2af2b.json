{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { parseAxisParam } from '../util';\nimport { abs } from './abs';\nimport * as axis_util from './axis_util';\nimport { max } from './max';\nimport { min } from './min';\nimport { op } from './operation';\nimport { pow } from './pow';\nimport { reshape } from './reshape';\nimport { scalar } from './scalar';\nimport { sqrt } from './sqrt';\nimport { square } from './square';\nimport { sum } from './sum';\n/**\r\n * Computes the norm of scalar, vectors, and matrices.\r\n * This function can compute several different vector norms (the 1-norm, the\r\n * Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)\r\n * and matrix norms (Frobenius, 1-norm, and inf-norm).\r\n *\r\n * ```js\r\n * const x = tf.tensor1d([1, 2, 3, 4]);\r\n *\r\n * x.norm().print();  // or tf.norm(x)\r\n * ```\r\n *\r\n * @param x The input array.\r\n * @param ord Optional. Order of the norm. Supported norm types are\r\n * following:\r\n *\r\n *  | ord        | norm for matrices         | norm for vectors\r\n *  |------------|---------------------------|---------------------\r\n *  |'euclidean' |Frobenius norm             |2-norm\r\n *  |'fro'       |Frobenius norm\t           |\r\n *  |Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))\r\n *  |-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))\r\n *  |1           |max(sum(abs(x), axis=0))   |sum(abs(x))\r\n *  |2           |                           |sum(abs(x)^2)^1/2*\r\n *\r\n * @param axis Optional. If axis is null (the default), the input is\r\n * considered a vector and a single vector norm is computed over the entire\r\n * set of values in the Tensor, i.e. norm(x, ord) is equivalent\r\n * to norm(x.reshape([-1]), ord). If axis is a integer, the input\r\n * is considered a batch of vectors, and axis determines the axis in x\r\n * over which to compute vector norms. If axis is a 2-tuple of integer it is\r\n * considered a batch of matrices and axis determines the axes in NDArray\r\n * over which to compute a matrix norm.\r\n * @param keepDims Optional. If true, the norm have the same dimensionality\r\n * as the input.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Matrices'}\r\n */\nfunction norm_(x, ord = 'euclidean', axis = null, keepDims = false) {\n  x = convertToTensor(x, 'x', 'norm');\n  const norm = normImpl(x, ord, axis);\n  let keepDimsShape = norm.shape;\n  if (keepDims) {\n    const axes = parseAxisParam(axis, x.shape);\n    keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);\n  }\n  return reshape(norm, keepDimsShape);\n}\nfunction normImpl(x, p, axis = null) {\n  if (x.rank === 0) {\n    return abs(x);\n  }\n  // consider vector when no axis is specified\n  if (x.rank !== 1 && axis === null) {\n    return normImpl(reshape(x, [-1]), p, axis);\n  }\n  // vector\n  if (x.rank === 1 || typeof axis === 'number' || Array.isArray(axis) && axis.length === 1) {\n    if (p === 1) {\n      return sum(abs(x), axis);\n    }\n    if (p === Infinity) {\n      return max(abs(x), axis);\n    }\n    if (p === -Infinity) {\n      return min(abs(x), axis);\n    }\n    if (p === 'euclidean' || p === 2) {\n      // norm(x, 2) = sum(abs(xi) ^ 2) ^ 1/2\n      return sqrt(sum(pow(abs(x), scalar(2, 'int32')), axis));\n    }\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n  // matrix (assumption axis[0] < axis[1])\n  if (Array.isArray(axis) && axis.length === 2) {\n    if (p === 1) {\n      return max(sum(abs(x), axis[0]), axis[1] - 1);\n    }\n    if (p === Infinity) {\n      return max(sum(abs(x), axis[1]), axis[0]);\n    }\n    if (p === -Infinity) {\n      return min(sum(abs(x), axis[1]), axis[0]);\n    }\n    if (p === 'fro' || p === 'euclidean') {\n      // norm(x) = sqrt(sum(pow(x, 2)))\n      return sqrt(sum(square(x), axis));\n    }\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n  throw new Error(`Error in norm: invalid axis: ${axis}`);\n}\nexport const norm = op({\n  norm_\n});","map":null,"metadata":{},"sourceType":"module"}