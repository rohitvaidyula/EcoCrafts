{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { assert, assertShapesMatch, getTypedArrayFromDType } from '../util';\nimport { tensor } from './tensor';\n/**\r\n * Returns whether the targets are in the top K predictions.\r\n *\r\n * ```js\r\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\r\n * const targets = tf.tensor1d([2, 0]);\r\n * const precision = await tf.inTopKAsync(predictions, targets);\r\n * precision.print();\r\n * ```\r\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\r\n *     at least `k`.\r\n * @param targets 1-D or higher `tf.Tensor`.\r\n * @param k Optional Number of top elements to look at for computing precision,\r\n *     default to 1.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\r\n */\nasync function inTopKAsync_(predictions, targets, k = 1) {\n  const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n  const $targets = convertToTensor(targets, 'targets', 'inTopK');\n  assert($predictions.rank > 1, () => 'inTopK() expects the predictions to be of rank 2 or higher, ' + `but got ${$predictions.rank}`);\n  assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than ` + `targets rank, but got predictions rank ` + `${$predictions.rank} and targets rank ${$targets.rank}`);\n  assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, ` + 'except the last dimension.');\n  const lastDim = $predictions.shape[$predictions.shape.length - 1];\n  assert(k > 0 && k <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` + `dimension (${lastDim}), but got ${k}`);\n  const predictionsVals = await $predictions.data();\n  const targetsVals = await $targets.data();\n  // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n  // and look up topK along lastDim.\n  const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n  const precision = getTypedArrayFromDType('bool', batch);\n  for (let b = 0; b < batch; b++) {\n    const offset = b * size;\n    const vals = predictionsVals.subarray(offset, offset + size);\n    const valAndInd = [];\n    for (let i = 0; i < vals.length; i++) {\n      valAndInd.push({\n        value: vals[i],\n        index: i\n      });\n    }\n    valAndInd.sort((a, b) => b.value - a.value);\n    precision[b] = 0;\n    for (let i = 0; i < k; i++) {\n      if (valAndInd[i].index === targetsVals[b]) {\n        precision[b] = 1;\n        break;\n      }\n    }\n  }\n  if (predictions !== $predictions) {\n    $predictions.dispose();\n  }\n  if (targets !== $targets) {\n    $targets.dispose();\n  }\n  // Output precision has the same shape as targets.\n  return tensor(precision, $targets.shape, 'bool');\n}\nexport const inTopKAsync = inTopKAsync_;","map":null,"metadata":{},"sourceType":"module"}