{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\n/**\r\n * Returns the dimensions in the input shape that are broadcasted to\r\n * produce the provided output shape.\r\n *\r\n * The returned dimensions are 0-indexed and sorted. An example:\r\n * inShape = [4, 1, 3]\r\n * outShape = [5, 4, 3, 3]\r\n * result = [1]. Dimension 1 (2nd dimension of input) gets broadcasted 1 => 3.\r\n */\nexport function getBroadcastDims(inShape, outShape) {\n  const inRank = inShape.length;\n  const dims = [];\n  for (let i = 0; i < inRank; i++) {\n    const dim = inRank - 1 - i;\n    const a = inShape[dim] || 1;\n    const b = outShape[outShape.length - 1 - i] || 1;\n    if (b > 1 && a === 1) {\n      dims.unshift(dim);\n    }\n  }\n  return dims;\n}\n/**\r\n * Returns the axes in the output space that should be reduced to produce\r\n * the input space.\r\n */\nexport function getReductionAxes(inShape, outShape) {\n  const result = [];\n  for (let i = 0; i < outShape.length; i++) {\n    const inDim = inShape[inShape.length - i - 1];\n    const outAxis = outShape.length - i - 1;\n    const outDim = outShape[outAxis];\n    if (inDim == null || inDim === 1 && outDim > 1) {\n      result.unshift(outAxis);\n    }\n  }\n  return result;\n}\nexport function assertAndGetBroadcastShape(shapeA, shapeB) {\n  const result = [];\n  const l = Math.max(shapeA.length, shapeB.length);\n  for (let i = 0; i < l; i++) {\n    let a = shapeA[shapeA.length - i - 1];\n    if (a == null) {\n      a = 1;\n    }\n    let b = shapeB[shapeB.length - i - 1];\n    if (b == null) {\n      b = 1;\n    }\n    if (a === 1) {\n      result.unshift(b);\n    } else if (b === 1) {\n      result.unshift(a);\n    } else if (a !== b) {\n      const errMsg = `Operands could not be broadcast together with shapes ` + `${shapeA} and ${shapeB}.`;\n      throw Error(errMsg);\n    } else {\n      result.unshift(a);\n    }\n  }\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}