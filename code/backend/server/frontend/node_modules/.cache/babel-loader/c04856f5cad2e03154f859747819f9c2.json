{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { ENGINE } from '../engine';\nimport { SparseToDense } from '../kernel_names';\nimport * as sparse_to_dense from '../ops/sparse_to_dense_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\r\n * Converts a sparse representation into a dense tensor.\r\n *\r\n * Builds an array dense with shape outputShape such that:\r\n *\r\n * // If sparseIndices is scalar\r\n * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)\r\n *\r\n * // If sparseIndices is a vector, then for each i\r\n * dense[sparseIndices[i]] = sparseValues[i]\r\n *\r\n * // If sparseIndices is an n by d matrix, then for each i in [0, n)\r\n * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]\r\n * All other values in dense are set to defaultValue. If sparseValues is a\r\n * scalar, all sparse indices are set to this single value.\r\n *\r\n * If indices are repeated the final value is summed over all values for those\r\n * indices.\r\n *\r\n * ```js\r\n * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');\r\n * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');\r\n * const shape = [8];\r\n * tf.sparseToDense(indices, values, shape).print();\r\n * ```\r\n *\r\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\r\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\r\n * placed.\r\n * @param sparseValues A 0-D or 1-D Tensor. Values\r\n * corresponding to each row of sparseIndices, or a scalar value to be used for\r\n * all sparse indices.\r\n * @param outputShape Shape of the dense output tensor. the type is inferred.\r\n * @param defaultValue Scalar. Value to set for indices not specified in\r\n * sparseIndices. Defaults to zero.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'Normalization'}\r\n */\nfunction sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {\n  const $sparseIndices = convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');\n  const $sparseValues = convertToTensor(sparseValues, 'sparseValues', 'sparseToDense');\n  const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);\n  sparse_to_dense.validateInput($sparseIndices, $sparseValues, outputShape, $defaultValue);\n  const inputs = {\n    sparseIndices: $sparseIndices,\n    sparseValues: $sparseValues,\n    defaultValue: $defaultValue\n  };\n  const attrs = {\n    outputShape\n  };\n  return ENGINE.runKernel(SparseToDense, inputs, attrs);\n}\nexport const sparseToDense = op({\n  sparseToDense_\n});","map":null,"metadata":{},"sourceType":"module"}