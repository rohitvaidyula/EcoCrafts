{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getPadding, getParamValue } from './utils';\nfunction fusedConvAndDepthWiseParams(node, tensorMap, context) {\n  const [extraOp, activationFunc] = getParamValue('fusedOps', node, tensorMap, context);\n  const isBiasAdd = extraOp === 'biasadd';\n  const isPrelu = activationFunc === 'prelu';\n  const isBatchNorm = extraOp === 'fusedbatchnorm';\n  const numArgs = getParamValue('numArgs', node, tensorMap, context);\n  if (isBiasAdd) {\n    if (isPrelu && numArgs !== 2) {\n      throw new Error('FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu ' + 'must have two extra arguments: bias and alpha.');\n    }\n    if (!isPrelu && numArgs !== 1) {\n      throw new Error('FusedConv2d and DepthwiseConv2d with BiasAdd must have ' + 'one extra argument: bias.');\n    }\n  }\n  if (isBatchNorm) {\n    throw new Error('FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.');\n  }\n  const stride = getParamValue('strides', node, tensorMap, context);\n  const pad = getPadding(node, tensorMap, context);\n  const dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n  const dilations = getParamValue('dilations', node, tensorMap, context);\n  const [biasArg, preluArg] = getParamValue('args', node, tensorMap, context);\n  const leakyreluAlpha = getParamValue('leakyreluAlpha', node, tensorMap, context);\n  return {\n    stride,\n    pad,\n    dataFormat,\n    dilations,\n    biasArg,\n    preluArg,\n    activationFunc,\n    leakyreluAlpha\n  };\n}\nexport const executeOp = (node, tensorMap, context) => {\n  switch (node.op) {\n    case 'Conv1D':\n      {\n        const stride = getParamValue('stride', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        const dilation = getParamValue('dilation', node, tensorMap, context);\n        return [tfOps.conv1d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];\n      }\n    case 'Conv2D':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getPadding(node, tensorMap, context);\n        const dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        const dilations = getParamValue('dilations', node, tensorMap, context);\n        return [tfOps.conv2d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[1], dilations[2]])];\n      }\n    case '_FusedConv2D':\n      {\n        const {\n          stride,\n          pad,\n          dataFormat,\n          dilations,\n          biasArg,\n          preluArg,\n          activationFunc,\n          leakyreluAlpha\n        } = fusedConvAndDepthWiseParams(node, tensorMap, context);\n        return [tfOps.fused.conv2d({\n          x: getParamValue('x', node, tensorMap, context),\n          filter: getParamValue('filter', node, tensorMap, context),\n          strides: [stride[1], stride[2]],\n          pad: pad,\n          dataFormat: dataFormat,\n          dilations: [dilations[1], dilations[2]],\n          bias: biasArg,\n          activation: activationFunc,\n          preluActivationWeights: preluArg,\n          leakyreluAlpha\n        })];\n      }\n    case 'FusedDepthwiseConv2dNative':\n      {\n        const {\n          stride,\n          pad,\n          dataFormat,\n          dilations,\n          biasArg,\n          preluArg,\n          activationFunc,\n          leakyreluAlpha\n        } = fusedConvAndDepthWiseParams(node, tensorMap, context);\n        return [tfOps.fused.depthwiseConv2d({\n          x: getParamValue('x', node, tensorMap, context),\n          filter: getParamValue('filter', node, tensorMap, context),\n          strides: [stride[1], stride[2]],\n          pad: pad,\n          dataFormat: dataFormat,\n          dilations: [dilations[1], dilations[2]],\n          bias: biasArg,\n          activation: activationFunc,\n          preluActivationWeights: preluArg,\n          leakyreluAlpha\n        })];\n      }\n    case 'Conv2DBackpropInput':\n    case 'Conv2dTranspose':\n      {\n        const shape = getParamValue('outputShape', node, tensorMap, context);\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getPadding(node, tensorMap, context);\n        return [tfOps.conv2dTranspose(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), shape, [stride[1], stride[2]], pad)];\n      }\n    case 'DepthwiseConv2dNative':\n    case 'DepthwiseConv2d':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getPadding(node, tensorMap, context);\n        const dilations = getParamValue('dilations', node, tensorMap, context);\n        const dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        return [tfOps.depthwiseConv2d(getParamValue('input', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[1], dilations[2]])];\n      }\n    case 'Conv3D':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const dataFormat = getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n        const dilations = getParamValue('dilations', node, tensorMap, context);\n        return [tfOps.conv3d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [stride[1], stride[2], stride[3]], pad, dataFormat, [dilations[1], dilations[2], dilations[3]])];\n      }\n    case 'AvgPool':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [tfOps.avgPool(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];\n      }\n    case 'MaxPool':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [tfOps.maxPool(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];\n      }\n    case 'MaxPoolWithArgmax':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        const includeBatchInIndex = getParamValue('includeBatchInIndex', node, tensorMap, context);\n        const {\n          result,\n          indexes\n        } = tfOps.maxPoolWithArgmax(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad, includeBatchInIndex);\n        return [result, indexes];\n      }\n    case 'AvgPool3D':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [tfOps.avgPool3d(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad)];\n      }\n    case 'MaxPool3D':\n      {\n        const stride = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const kernelSize = getParamValue('kernelSize', node, tensorMap, context);\n        return [tfOps.maxPool3d(getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad)];\n      }\n    case 'Dilation2D':\n      {\n        const strides = getParamValue('strides', node, tensorMap, context);\n        const pad = getParamValue('pad', node, tensorMap, context);\n        const dilations = getParamValue('dilations', node, tensorMap, context);\n        // strides: [1, stride_height, stride_width, 1].\n        const strideHeight = strides[1];\n        const strideWidth = strides[2];\n        // dilations: [1, dilation_height, dilation_width, 1].\n        const dilationHeight = dilations[1];\n        const dilationWidth = dilations[2];\n        return [tfOps.dilation2d(getParamValue('x', node, tensorMap, context), getParamValue('filter', node, tensorMap, context), [strideHeight, strideWidth], pad, [dilationHeight, dilationWidth], 'NHWC' /* dataFormat */)];\n      }\n\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'convolution';","map":null,"metadata":{},"sourceType":"module"}