{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { clone, util } from '@tensorflow/tfjs-core';\nexport function getParamValue(paramName, node, tensorMap, context, resourceManager) {\n  const inputParam = node.inputParams[paramName];\n  if (inputParam && inputParam.inputIndexStart !== undefined) {\n    const start = inputParam.inputIndexStart;\n    const end = inputParam.inputIndexEnd === 0 ? undefined : inputParam.inputIndexEnd === undefined ? start + 1 : inputParam.inputIndexEnd;\n    if (inputParam.type === 'tensor') {\n      return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);\n    }\n    if (inputParam.type === 'tensors') {\n      const inputs = node.inputNames.slice(start, end);\n      return inputs.map(name => getTensor(name, tensorMap, context, resourceManager));\n    }\n    const tensor = getTensor(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);\n    const data = tensor.dataSync();\n    return inputParam.type === 'number' ? data[0] : util.toNestedArray(tensor.shape, data);\n  }\n  const attrParam = node.attrParams[paramName];\n  return attrParam && attrParam.value;\n}\n/**\r\n * Retrieve the tensor from tensorsMap based on input name.\r\n * @param name Node input name\r\n * @param tensorsMap Tensors map keyed by the node\r\n * @param context contains tensors and information for running the current node.\r\n * @param resourceManager Optional. Contains global resources of the model.\r\n */\nexport function getTensor(name, tensorsMap, context, resourceManager) {\n  const [nodeName, index] = parseNodeName(name);\n  if (resourceManager != null) {\n    const tensor = resourceManager.getHashTableHandleByName(nodeName);\n    if (tensor != null) {\n      return tensor;\n    }\n  }\n  const contextId = context.currentContextIds.find(contextId => {\n    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n  });\n  return contextId !== undefined ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : undefined;\n}\n/**\r\n * Retrieve the tensors based on input name for current context.\r\n * @param name Node input name\r\n * @param tensorsMap Tensors map keyed by the node\r\n */\nexport function getTensorsForCurrentContenxt(name, tensorsMap, context) {\n  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n/**\r\n * Returns the node name and index from the Node input name.\r\n * @param inputName The input name of the node, in format of\r\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\r\n * default to 0.\r\n */\nexport function getNodeNameAndIndex(inputName, context) {\n  const [nodeName, index] = parseNodeName(inputName);\n  return [getNodeNameWithContextId(nodeName, context && context.currentContextId), index];\n}\nfunction getNodeNameWithContextId(name, contextId) {\n  return !!contextId ? `${name}-${contextId}` : name;\n}\nexport function parseNodeName(name) {\n  const parts = name.split(':');\n  if (parts.length === 1) {\n    return [name, 0];\n  }\n  const nodeName = parts[0];\n  return [nodeName, Number(parts[parts.length - 1])];\n}\nexport function split(arr, size) {\n  const res = [];\n  for (let i = 0; i < arr.length; i += size) {\n    res.push(arr.slice(i, i + size));\n  }\n  return res;\n}\nexport function getPadding(node, tensorMap, context) {\n  let pad = getParamValue('pad', node, tensorMap, context);\n  if (pad === 'explicit') {\n    // This is 1d array, we need to convert it to 2d array\n    pad = getParamValue('explicitPaddings', node, tensorMap, context);\n    const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];\n    for (let i = 0; i < 4; i++) {\n      explicitPadding[i][0] = pad[i * 2];\n      explicitPadding[i][1] = pad[i * 2 + 1];\n    }\n    return explicitPadding;\n  }\n  return pad;\n}\n/**\r\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\r\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\r\n *  internally they use a tensor as the id for TensorArray and TensorList, and\r\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\r\n * These id tensors have been marked as kept in the backend, we need avoid clone\r\n * them in order to create new Tensor.id.\r\n * @param tensor\r\n */\nexport function cloneTensor(tensor) {\n  return tensor.kept ? tensor : clone(tensor);\n}","map":null,"metadata":{},"sourceType":"module"}