{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n * =============================================================================\r\n */\n/**\r\n * A ring buffer, providing O(1) FIFO, LIFO, and related operations.\r\n */\nexport class RingBuffer {\n  /**\r\n   * Constructs a `RingBuffer`.\r\n   * @param capacity The number of items that the buffer can accomodate.\r\n   */\n  constructor(capacity) {\n    this.capacity = capacity;\n    // Note we store the indices in the range 0 <= index < 2*capacity.\n    // This allows us to distinguish the full from the empty case.\n    // See https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/\n    this.begin = 0; // inclusive\n    this.end = 0; // exclusive\n    if (capacity == null) {\n      throw new RangeError('Can\\'t create a ring buffer of unknown capacity.');\n    }\n    if (capacity < 1) {\n      throw new RangeError('Can\\'t create ring buffer of capacity < 1.');\n    }\n    this.data = new Array(capacity);\n    this.doubledCapacity = 2 * capacity;\n  }\n  /**\r\n   * Map any index into the range 0 <= index < 2*capacity.\r\n   */\n  wrap(index) {\n    // don't trust % on negative numbers\n    while (index < 0) {\n      index += this.doubledCapacity;\n    }\n    return index % this.doubledCapacity;\n  }\n  get(index) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t get item at a negative index.');\n    }\n    return this.data[index % this.capacity];\n  }\n  set(index, value) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t set item at a negative index.');\n    }\n    this.data[index % this.capacity] = value;\n  }\n  /**\r\n   * Returns the current number of items in the buffer.\r\n   */\n  length() {\n    let length = this.end - this.begin;\n    if (length < 0) {\n      length = this.doubledCapacity + length;\n    }\n    return length;\n  }\n  /**\r\n   * Reports whether the buffer is full.\r\n   * @returns true if the number of items in the buffer equals its capacity, and\r\n   *   false otherwise.\r\n   */\n  isFull() {\n    return this.length() === this.capacity;\n  }\n  /**\r\n   * Reports whether the buffer is empty.\r\n   * @returns true if the number of items in the buffer equals zero, and\r\n   *   false otherwise.\r\n   */\n  isEmpty() {\n    return this.length() === 0;\n  }\n  /**\r\n   * Adds an item to the end of the buffer.\r\n   */\n  push(value) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n    this.set(this.end, value);\n    this.end = this.wrap(this.end + 1);\n  }\n  /**\r\n   * Adds many items to the end of the buffer, in order.\r\n   */\n  pushAll(values) {\n    for (const value of values) {\n      this.push(value);\n    }\n  }\n  /**\r\n   * Removes and returns the last item in the buffer.\r\n   */\n  pop() {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    this.end = this.wrap(this.end - 1);\n    const result = this.get(this.end);\n    this.set(this.end, undefined);\n    return result;\n  }\n  /**\r\n   * Adds an item to the beginning of the buffer.\r\n   */\n  unshift(value) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n    this.begin = this.wrap(this.begin - 1);\n    this.set(this.begin, value);\n  }\n  /**\r\n   * Removes and returns the first item in the buffer.\r\n   */\n  shift() {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    const result = this.get(this.begin);\n    this.set(this.begin, undefined);\n    this.begin = this.wrap(this.begin + 1);\n    return result;\n  }\n  /**\r\n   * Removes and returns a specific item in the buffer, and moves the last item\r\n   * to the vacated slot.  This is useful for implementing a shuffling stream.\r\n   * Note that this operation necessarily scrambles the original order.\r\n   *\r\n   * @param relativeIndex: the index of the item to remove, relative to the\r\n   *   first item in the buffer (e.g., hiding the ring nature of the underlying\r\n   *   storage).\r\n   */\n  shuffleExcise(relativeIndex) {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    const index = this.wrap(this.begin + relativeIndex);\n    const result = this.get(index);\n    this.set(index, this.pop());\n    return result;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}