{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2018 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nclass PassthroughLoader {\n  constructor(modelArtifacts) {\n    this.modelArtifacts = modelArtifacts;\n  }\n  async load() {\n    return this.modelArtifacts;\n  }\n}\nclass PassthroughSaver {\n  constructor(saveHandler) {\n    this.saveHandler = saveHandler;\n  }\n  async save(modelArtifacts) {\n    return this.saveHandler(modelArtifacts);\n  }\n}\n/**\r\n * Creates an IOHandler that loads model artifacts from memory.\r\n *\r\n * When used in conjunction with `tf.loadLayersModel`, an instance of\r\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\r\n *\r\n * ```js\r\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\r\n *     modelTopology, weightSpecs, weightData));\r\n * ```\r\n *\r\n * @param modelArtifacts a object containing model topology (i.e., parsed from\r\n *   the JSON format).\r\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\r\n *   names, shapes, types, and quantization of the weight data.\r\n * @param weightData A single `ArrayBuffer` containing the weight data,\r\n *   concatenated in the order described by the weightSpecs.\r\n * @param trainingConfig Model training configuration. Optional.\r\n *\r\n * @returns A passthrough `IOHandler` that simply loads the provided data.\r\n */\nexport function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n  if (arguments.length === 1) {\n    const isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;\n    if (isModelArtifacts) {\n      return new PassthroughLoader(modelArtifacts);\n    } else {\n      // Legacy support: with only modelTopology.\n      // TODO(cais): Remove this deprecated API.\n      console.warn('Please call tf.io.fromMemory() with only one argument. ' + 'The argument should be of type ModelArtifacts. ' + 'The multi-argument signature of tf.io.fromMemory() has been ' + 'deprecated and will be removed in a future release.');\n      return new PassthroughLoader({\n        modelTopology: modelArtifacts\n      });\n    }\n  } else {\n    // Legacy support.\n    // TODO(cais): Remove this deprecated API.\n    console.warn('Please call tf.io.fromMemory() with only one argument. ' + 'The argument should be of type ModelArtifacts. ' + 'The multi-argument signature of tf.io.fromMemory() has been ' + 'deprecated and will be removed in a future release.');\n    return new PassthroughLoader({\n      modelTopology: modelArtifacts,\n      weightSpecs,\n      weightData,\n      trainingConfig\n    });\n  }\n}\n/**\r\n * Creates an IOHandler that passes saved model artifacts to a callback.\r\n *\r\n * ```js\r\n * function handleSave(artifacts) {\r\n *   // ... do something with the artifacts ...\r\n *   return {modelArtifactsInfo: {...}, ...};\r\n * }\r\n *\r\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\r\n * ```\r\n *\r\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\r\n *     `SaveResult`.\r\n */\nexport function withSaveHandler(saveHandler) {\n  return new PassthroughSaver(saveHandler);\n}","map":null,"metadata":{},"sourceType":"module"}