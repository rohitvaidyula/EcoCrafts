{"ast":null,"code":"import { convertToTensor, convertToTensorArray } from '../tensor_util_env';\nimport { op } from './operation';\n/**\r\n * Computes the next states and outputs of a stack of LSTMCells.\r\n *\r\n * Each cell output is used as input to the next cell.\r\n *\r\n * Returns `[cellState, cellOutput]`.\r\n *\r\n * Derived from tf.contrib.rn.MultiRNNCell.\r\n *\r\n * @param lstmCells Array of LSTMCell functions.\r\n * @param data The input to the cell.\r\n * @param c Array of previous cell states.\r\n * @param h Array of previous cell outputs.\r\n *\r\n * @doc {heading: 'Operations', subheading: 'RNN'}\r\n */\nfunction multiRNNCell_(lstmCells, data, c, h) {\n  const $data = convertToTensor(data, 'data', 'multiRNNCell');\n  const $c = convertToTensorArray(c, 'c', 'multiRNNCell');\n  const $h = convertToTensorArray(h, 'h', 'multiRNNCell');\n  let input = $data;\n  const newStates = [];\n  for (let i = 0; i < lstmCells.length; i++) {\n    const output = lstmCells[i](input, $c[i], $h[i]);\n    newStates.push(output[0]);\n    newStates.push(output[1]);\n    input = output[1];\n  }\n  const newC = [];\n  const newH = [];\n  for (let i = 0; i < newStates.length; i += 2) {\n    newC.push(newStates[i]);\n    newH.push(newStates[i + 1]);\n  }\n  return [newC, newH];\n}\nexport const multiRNNCell = op({\n  multiRNNCell_\n});","map":null,"metadata":{},"sourceType":"module"}