{"ast":null,"code":"/**\r\n * @license\r\n * Copyright 2020 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nimport { concat, keep, reshape, scalar, slice, stack, tensor, tidy, unstack } from '@tensorflow/tfjs-core';\nimport { assertShapesMatchAllowUndefinedSize } from './tensor_utils';\n/**\r\n * TensorList stores a container of `tf.Tensor` objects, which are accessible\r\n * via tensors field.\r\n *\r\n * In order to get a copy of the underlying list, use the copy method:\r\n * ```\r\n *    TensorList b = a.copy();\r\n *    b.tensors().pushBack(t);  // This does not modify a.tensors().\r\n * ```\r\n *\r\n * Note that this is not a deep copy: the memory locations of the underlying\r\n * tensors will still point to the same locations of the corresponding tensors\r\n * in the original.\r\n */\nexport class TensorList {\n  /**\r\n   *\r\n   * @param tensors list of tensors\r\n   * @param elementShape shape of each tensor\r\n   * @param elementDtype data type of each tensor\r\n   * @param maxNumElements The maximum allowed size of `tensors`. Defaults to -1\r\n   *   meaning that the size of `tensors` is unbounded.\r\n   */\n  constructor(tensors, elementShape, elementDtype, maxNumElements = -1) {\n    this.tensors = tensors;\n    this.elementShape = elementShape;\n    this.elementDtype = elementDtype;\n    if (tensors != null) {\n      tensors.forEach(tensor => {\n        if (elementDtype !== tensor.dtype) {\n          throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${tensor.dtype}`);\n        }\n        assertShapesMatchAllowUndefinedSize(elementShape, tensor.shape, 'TensorList shape mismatch: ');\n        keep(tensor);\n      });\n    }\n    this.idTensor = scalar(0);\n    this.maxNumElements = maxNumElements;\n    keep(this.idTensor);\n  }\n  get id() {\n    return this.idTensor.id;\n  }\n  /**\r\n   * Get a new TensorList containing a copy of the underlying tensor container.\r\n   */\n  copy() {\n    return new TensorList([...this.tensors], this.elementShape, this.elementDtype);\n  }\n  /**\r\n   * Dispose the tensors and idTensor and clear the tensor list.\r\n   */\n  clearAndClose(keepIds) {\n    this.tensors.forEach(tensor => {\n      if (keepIds == null || !keepIds.has(tensor.id)) {\n        tensor.dispose();\n      }\n    });\n    this.tensors.length = 0;\n    this.idTensor.dispose();\n  }\n  /**\r\n   * The size of the tensors in the tensor list.\r\n   */\n  size() {\n    return this.tensors.length;\n  }\n  /**\r\n   * Return a tensor that stacks a list of rank-R tf.Tensors into one rank-(R+1)\r\n   * tf.Tensor.\r\n   * @param elementShape shape of each tensor\r\n   * @param elementDtype data type of each tensor\r\n   * @param numElements the number of elements to stack\r\n   */\n  stack(elementShape, elementDtype, numElements = -1) {\n    if (elementDtype !== this.elementDtype) {\n      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);\n    }\n    if (numElements !== -1 && this.tensors.length !== numElements) {\n      throw new Error(`Operation expected a list with ${numElements} elements but got a list with ${this.tensors.length} elements.`);\n    }\n    assertShapesMatchAllowUndefinedSize(elementShape, this.elementShape, 'TensorList shape mismatch: ');\n    return tidy(() => {\n      const reshapedTensors = this.tensors.map(tensor => reshape(tensor, elementShape));\n      return stack(reshapedTensors, 0);\n    });\n  }\n  /**\r\n   * Pop a tensor from the end of the list.\r\n   * @param elementShape shape of the tensor\r\n   * @param elementDtype data type of the tensor\r\n   */\n  popBack(elementShape, elementDtype) {\n    if (elementDtype !== this.elementDtype) {\n      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);\n    }\n    if (this.size() === 0) {\n      throw new Error('Trying to pop from an empty list.');\n    }\n    const tensor = this.tensors.pop();\n    assertShapesMatchAllowUndefinedSize(tensor.shape, elementShape, 'TensorList shape mismatch: ');\n    return reshape(tensor, elementShape);\n  }\n  /**\r\n   * Push a tensor to the end of the list.\r\n   * @param tensor Tensor to be pushed.\r\n   */\n  pushBack(tensor) {\n    if (tensor.dtype !== this.elementDtype) {\n      throw new Error(`Invalid data types; op elements ${tensor.dtype}, but list elements ${this.elementDtype}`);\n    }\n    assertShapesMatchAllowUndefinedSize(tensor.shape, this.elementShape, 'TensorList shape mismatch: ');\n    if (this.maxNumElements === this.size()) {\n      throw new Error(`Trying to push element into a full list.`);\n    }\n    keep(tensor);\n    this.tensors.push(tensor);\n  }\n  /**\r\n   * Update the size of the list.\r\n   * @param size the new size of the list.\r\n   */\n  resize(size) {\n    if (size < 0) {\n      throw new Error(`TensorListResize expects size to be non-negative. Got: ${size}`);\n    }\n    if (this.maxNumElements !== -1 && size > this.maxNumElements) {\n      throw new Error(`TensorListResize input size ${size} is greater maxNumElement ${this.maxNumElements}.`);\n    }\n    this.tensors.length = size;\n  }\n  /**\r\n   * Retrieve the element at the provided index\r\n   * @param elementShape shape of the tensor\r\n   * @param elementDtype dtype of the tensor\r\n   * @param elementIndex index of the tensor\r\n   */\n  getItem(elementIndex, elementShape, elementDtype) {\n    if (elementDtype !== this.elementDtype) {\n      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);\n    }\n    if (elementIndex < 0 || elementIndex > this.tensors.length) {\n      throw new Error(`Trying to access element ${elementIndex} in a list with ${this.tensors.length} elements.`);\n    }\n    if (this.tensors[elementIndex] == null) {\n      throw new Error(`element at index ${elementIndex} is null.`);\n    }\n    assertShapesMatchAllowUndefinedSize(this.tensors[elementIndex].shape, elementShape, 'TensorList shape mismatch: ');\n    return this.tensors[elementIndex];\n  }\n  /**\r\n   * Set the tensor at the index\r\n   * @param elementIndex index of the tensor\r\n   * @param tensor the tensor to be inserted into the list\r\n   */\n  setItem(elementIndex, tensor) {\n    if (tensor.dtype !== this.elementDtype) {\n      throw new Error(`Invalid data types; op elements ${tensor.dtype}, but list elements ${this.elementDtype}`);\n    }\n    if (elementIndex < 0 || this.maxNumElements !== -1 && elementIndex >= this.maxNumElements) {\n      throw new Error(`Trying to set element ${elementIndex} in a list with max ${this.maxNumElements} elements.`);\n    }\n    assertShapesMatchAllowUndefinedSize(this.elementShape, tensor.shape, 'TensorList shape mismatch: ');\n    keep(tensor);\n    this.tensors[elementIndex] = tensor;\n  }\n  /**\r\n   * Return selected values in the TensorList as a stacked Tensor. All of\r\n   * selected values must have been written and their shapes must all match.\r\n   * @param indices indices of tensors to gather\r\n   * @param elementDtype output tensor dtype\r\n   * @param elementShape output tensor element shape\r\n   */\n  gather(indices, elementDtype, elementShape) {\n    if (elementDtype !== this.elementDtype) {\n      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);\n    }\n    assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, 'TensorList shape mismatch: ');\n    // When indices is greater than the size of the list, indices beyond the\n    // size of the list are ignored.\n    indices = indices.slice(0, this.size());\n    if (indices.length === 0) {\n      return tensor([], [0].concat(this.elementShape));\n    }\n    return tidy(() => {\n      const tensors = indices.map(i => reshape(this.tensors[i], elementShape));\n      return stack(tensors, 0);\n    });\n  }\n  /**\r\n   * Return the values in the TensorList as a concatenated Tensor.\r\n   * @param elementDtype output tensor dtype\r\n   * @param elementShape output tensor element shape\r\n   */\n  concat(elementDtype, elementShape) {\n    if (!!elementDtype && elementDtype !== this.elementDtype) {\n      throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${elementDtype}`);\n    }\n    assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, 'TensorList shape mismatch: ');\n    if (this.size() === 0) {\n      return tensor([], [0].concat(this.elementShape));\n    }\n    return tidy(() => {\n      const tensors = this.tensors.map(t => reshape(t, elementShape));\n      return concat(tensors, 0);\n    });\n  }\n}\n/**\r\n * Creates a TensorList which, when stacked, has the value of tensor.\r\n * @param tensor from tensor\r\n * @param elementShape output tensor element shape\r\n */\nexport function fromTensor(tensor, elementShape, elementDtype) {\n  const dtype = tensor.dtype;\n  if (tensor.shape.length < 1) {\n    throw new Error(`Tensor must be at least a vector, but saw shape: ${tensor.shape}`);\n  }\n  if (tensor.dtype !== elementDtype) {\n    throw new Error(`Invalid data types; op elements ${tensor.dtype}, but list elements ${elementDtype}`);\n  }\n  const outputShape = tensor.shape.slice(1);\n  assertShapesMatchAllowUndefinedSize(outputShape, elementShape, 'TensorList shape mismatch: ');\n  const tensorList = unstack(tensor);\n  return new TensorList(tensorList, elementShape, dtype);\n}\n/**\r\n * Return a TensorList of the given size with empty elements.\r\n * @param elementShape the shape of the future elements of the list\r\n * @param elementDtype the desired type of elements in the list\r\n * @param numElements the number of elements to reserve\r\n */\nexport function reserve(elementShape, elementDtype, numElements) {\n  return new TensorList([], elementShape, elementDtype, numElements);\n}\n/**\r\n * Put tensors at specific indices of a stacked tensor into a TensorList.\r\n * @param indices list of indices on how to scatter the tensor.\r\n * @param tensor input tensor.\r\n * @param elementShape the shape of the future elements of the list\r\n * @param numElements the number of elements to scatter\r\n */\nexport function scatter(tensor, indices, elementShape, numElements) {\n  if (indices.length !== tensor.shape[0]) {\n    throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor.shape[0]}`);\n  }\n  const maxIndex = Math.max(...indices);\n  if (numElements != null && numElements !== -1 && maxIndex >= numElements) {\n    throw new Error(`Max index must be < array size (${maxIndex}  vs. ${numElements})`);\n  }\n  const list = new TensorList([], elementShape, tensor.dtype, numElements);\n  const tensors = unstack(tensor, 0);\n  indices.forEach((value, index) => {\n    list.setItem(value, tensors[index]);\n  });\n  return list;\n}\n/**\r\n * Split the values of a Tensor into a TensorList.\r\n * @param length the lengths to use when splitting value along\r\n *    its first dimension.\r\n * @param tensor the tensor to split.\r\n * @param elementShape the shape of the future elements of the list\r\n */\nexport function split(tensor, length, elementShape) {\n  let totalLength = 0;\n  const cumulativeLengths = length.map(len => {\n    totalLength += len;\n    return totalLength;\n  });\n  if (totalLength !== tensor.shape[0]) {\n    throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${totalLength}, and tensor's shape is: ${tensor.shape}`);\n  }\n  const elementPerRow = totalLength === 0 ? 0 : tensor.size / totalLength;\n  const tensors = tidy(() => {\n    const tensors = [];\n    tensor = reshape(tensor, [1, totalLength, elementPerRow]);\n    for (let i = 0; i < length.length; ++i) {\n      const previousLength = i === 0 ? 0 : cumulativeLengths[i - 1];\n      const indices = [0, previousLength, 0];\n      const sizes = [1, length[i], elementPerRow];\n      tensors[i] = reshape(slice(tensor, indices, sizes), elementShape);\n    }\n    tensor.dispose();\n    return tensors;\n  });\n  const list = new TensorList([], elementShape, tensor.dtype, length.length);\n  for (let i = 0; i < tensors.length; i++) {\n    list.setItem(i, tensors[i]);\n  }\n  return list;\n}","map":null,"metadata":{},"sourceType":"module"}